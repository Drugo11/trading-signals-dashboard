# Trading System Prototype

This folder contains a Python module, `trading_system.py`, which
implements a simple yet extensible framework for testing
machine‑learning trading strategies on a small universe of assets.  The
code is fully self‑contained and can run without any external data
providers; if the `yfinance` package is available and network access
permits, it will download historical prices from Yahoo Finance.  When
that is not possible, it generates synthetic price series so you can
still run the pipeline end‑to‑end.

## Quick start

To run a basic backtest out of the box, open a terminal and execute:

```bash
python trading_system/trading_system.py
```

This will download (or simulate) data for a handful of large US
technology stocks, train an XGBoost model using walk‑forward cross
validation, generate long/short positions and output summary
statistics and the tail of the equity curve.

## Customising the universe

You can import the `run_backtest` function from the module and pass in
your own list of tickers and parameters.  For example:

```python
from trading_system.trading_system import run_backtest

result = run_backtest(
    tickers=["AAPL", "MSFT", "NVDA", "AMZN", "META", "GOOGL"],
    start="2018-01-01",
    horizon=5,
    n_splits=6,
    quantile=0.1,
    target_vol=0.10,
)
print(result.summary)
result.equity_curve.plot()
```

The `tickers` argument accepts any symbols supported by Yahoo
Finance.  Note that price history for illiquid or delisted instruments
may be sparse or unavailable.

## Understanding the pipeline

1. **Data fetching or simulation** – `fetch_price_data` tries to use
   `yfinance` to retrieve adjusted close prices.  If that fails, it
   generates synthetic data via a geometric Brownian motion model.

2. **Feature engineering** – `build_dataset` computes simple
   technical features (momentum and volatility) and reshapes the
   DataFrame into a long format with one row per `(date, ticker)`.

3. **Model training** – `run_backtest` uses `TimeSeriesSplit` to
   perform walk‑forward cross validation and fits an `XGBRegressor`
   (gradient boosting) on each fold.

4. **Position sizing** – predictions are converted into long/short
   signals by taking the top and bottom quantiles.  A volatility
   targeting scheme scales the positions so that the annualised
   volatility of the strategy matches `target_vol`.

5. **Backtesting** – daily returns are aggregated across tickers and
   compounded into an equity curve.  The module reports total return,
   CAGR, Sharpe ratio and maximum drawdown.

## Extending the framework

The current implementation is intentionally minimal.  To build a more
robust trading system, consider adding:

* Purging and embargoing around training and test splits to prevent
  look‑ahead bias.
* A richer set of features (e.g. macro variables, regime indicators,
  event embeddings) or meta‑labeling techniques.
* Execution cost modelling, including bid/ask spreads and liquidity
  constraints.
* Risk controls such as stop‑loss rules, position caps and
  kill‑switches on large drawdowns.

Feel free to modify and experiment – the code is provided as a
foundation for your own research.

## Visualising the signals

The ``app.html`` file in this directory provides a simple interactive
visualisation of the trading signals generated by the model.  After
running ``generate_signals_json.py``, a ``signals.js`` file will be
created that contains the predictions and long/short classifications
for each date and ticker.  Open ``app.html`` in a web browser (for
example by starting a local web server with ``python -m http.server``
and navigating to ``http://localhost:8000/trading_system/app.html``)
to explore the latest signals.  Use the date dropdown to select a
trading day; the table will display the predicted returns and
assigned signal (LONG, SHORT, or FLAT) for each asset, and the bar
chart visualises the same information.